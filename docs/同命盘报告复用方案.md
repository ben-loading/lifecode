# 同命盘报告复用方案（优化项第3点）

## 一、需求概述

**目标**：
1. **确保相同命盘的结果一致**：相同命盘（性别+出生年月日时）的用户看到完全相同的报告内容
2. **官方节省成本**：相同命盘不重复调用 LLM，直接复用已有报告内容，降低 API 调用成本

**重要说明**：
- **用户侧**：无论是否相同命盘，创建档案和生成报告都**正常扣费**（用户体验一致）
- **后端侧**：生成报告时，如果检测到相同命盘已有报告，直接复用报告内容（不调用 LLM），节省成本
- **结果**：相同命盘的用户看到一致的报告，官方节省 LLM 调用成本

**适用范围**：
- 主报告（MainReport）
- 四类深度报告（DeepReport）：未来运势、仕途探索、财富之路、爱情姻缘

## 二、命盘唯一性判断标准

### 2.1 核心字段
命盘由以下字段唯一确定：
- `gender`: 'male' | 'female'（性别）
- `birthDate`: string（出生日期时间，ISO 8601 格式）
- `birthLocation`: string（出生地区，用于真太阳时校准）

### 2.2 输入方式差异处理

用户输入可能采用不同方式：
1. **公历 + 具体时刻** (`birthCalendar='solar'`, `birthTimeMode='datetime'`)
   - `birthDate`: `"2020-01-15T14:30:00"`（已包含时区信息）
   - `birthLocation`: 必需（用于真太阳时校准）

2. **公历 + 时辰** (`birthCalendar='solar'`, `birthTimeMode='shichen'`)
   - `birthDate`: `"2020-01-15"`（仅日期）
   - `birthTimeBranch`: 0-11（时辰序号）
   - `birthLocation`: 不需要（时辰已包含时间信息）

3. **农历 + 具体时刻** (`birthCalendar='lunar'`, `birthTimeMode='datetime'`)
   - `lunarDate`: `"2020-01-15"`（农历日期）
   - `isLeapMonth`: boolean（是否闰月）
   - `birthDate`: `"2020-01-15T14:30:00"`（对应的公历日期时间）
   - `birthLocation`: 必需

4. **农历 + 时辰** (`birthCalendar='lunar'`, `birthTimeMode='shichen'`)
   - `lunarDate`: `"2020-01-15"`（农历日期）
   - `isLeapMonth`: boolean
   - `birthDate`: `"2020-01-15"`（对应的公历日期）
   - `birthTimeBranch`: 0-11
   - `birthLocation`: 不需要

### 2.3 标准化策略

**核心思路**：命盘由八字（年、月、日、时）决定，最终都会转换为时辰序号（0-12）。因此，应该直接匹配**性别 + 公历日期 + 时辰序号**，而不是匹配时间+地点。

**标准化字段**（用于查询匹配）：
- `normalizedBirthDate`: 公历日期，格式 `"YYYY-MM-DD"`（年-月-日）
  - 公历输入：直接使用 `birthDate` 的日期部分
  - 农历输入：先将农历转换为公历日期
- `normalizedTimeIndex`: 时辰序号，0-12（与 iztro 的 timeIndex 一致）
  - 时辰模式：直接使用 `birthTimeBranch`（0-12）
  - 具体时刻模式：应用真太阳时校准后，转换为时辰序号（`hourToTimeIndex(hour)`）

**说明**：
- 不需要存储"时间+地点"，只需要存储"时辰序号"
- 这样更简单、更准确，符合命理学的本质
- 例如：用户A输入"2020-01-15T14:30:00"（北京）和用户B输入"2020-01-15"+"午时"，都会转换为相同的 `normalizedBirthDate="2020-01-15"` 和 `normalizedTimeIndex=6`（午时），应该匹配

**注意**：
- 由于后端在生成报告时已经处理了公历/农历转换和真太阳时校准，我们可以：
  - **方案A（推荐）**：在后端生成报告时，将标准化后的 `normalizedBirthDateTime` 存储到 `Archive` 表或 `MainReport` 表
  - **方案B**：前端在创建档案前，调用后端 API 进行标准化转换和查询

## 三、实现方案

### 方案A：基于现有表查询（推荐）

#### 3.1 数据库变更

**新增字段到 `Archive` 表**：
```sql
ALTER TABLE Archive ADD COLUMN normalized_birth_date DATE;  -- 公历日期 YYYY-MM-DD
ALTER TABLE Archive ADD COLUMN normalized_time_index INTEGER;  -- 时辰序号 0-12
CREATE INDEX idx_archive_normalized_birth ON Archive(gender, normalized_birth_date, normalized_time_index);
```

**说明**：
- `normalized_birth_date`: 标准化后的公历日期（年-月-日），格式 `DATE`
- `normalized_time_index`: 标准化后的时辰序号（0-12），与 iztro 的 timeIndex 一致
- 索引用于快速查询相同命盘（性别 + 日期 + 时辰）

#### 3.2 后端 API 变更

**1. 新增查询接口**：
```typescript
// GET /api/archives/find-by-birth-info
// 查询是否存在相同命盘的档案
interface FindArchiveByBirthInfoParams {
  gender: 'male' | 'female'
  normalizedBirthDateTime: string  // ISO 8601
  normalizedBirthLocation: string
}
// 返回: { archiveId: string | null, hasMainReport: boolean, hasDeepReports: string[] }
```

**2. 修改创建档案接口**：
- 在 `createArchive` 时，计算并存储 `normalized_birth_date_time` 和 `normalized_birth_location`
- 创建档案前，先调用查询接口检查是否有相同命盘

**3. 新增报告关联接口**：
```typescript
// POST /api/reports/link-to-archive
// 将源档案的报告关联到目标档案
interface LinkReportsBody {
  sourceArchiveId: string  // 已有报告的档案
  targetArchiveId: string  // 新创建的档案
  reportTypes: ('main' | 'future-fortune' | 'career-path' | 'wealth-road' | 'love-marriage')[]
}
```

#### 3.3 前端变更

**前端无需变更**：
- 前端保持现有流程不变
- 用户创建档案 → 扣费 → 发起生成任务
- 后端在生成任务时自动检测并复用

**说明**：复用逻辑完全在后端实现，前端无感知，用户体验一致。

### 方案B：新增独立报告库表（备选）

如果希望报告完全独立于档案，可以新增一个 `ReportLibrary` 表：

```sql
CREATE TABLE ReportLibrary (
  id UUID PRIMARY KEY,
  gender TEXT NOT NULL,
  normalized_birth_date_time TIMESTAMP NOT NULL,
  normalized_birth_location TEXT NOT NULL,
  main_report_id UUID REFERENCES MainReport(id),
  deep_reports JSONB,  -- { "future-fortune": reportId, ... }
  created_at TIMESTAMP NOT NULL,
  updated_at TIMESTAMP NOT NULL,
  UNIQUE(gender, normalized_birth_date_time, normalized_birth_location)
);
```

**优点**：
- 报告与档案完全解耦
- 更容易管理报告版本

**缺点**：
- 需要额外的数据迁移
- 查询逻辑更复杂

## 四、技术实现细节

### 4.1 标准化转换逻辑（后端）

需要在后端实现以下转换函数（复用 `iztro-service.ts` 的逻辑）：

```typescript
// 将各种输入方式转换为标准化的日期和时辰序号
// 复用 iztro-service.ts 中的 calculateAstrolabe 逻辑
function normalizeBirthInfo(archive: ApiArchive): {
  normalizedBirthDate: string  // "YYYY-MM-DD"
  normalizedTimeIndex: number  // 0-12
} {
  const useLunar = archive.birthCalendar === 'lunar'
  const useShichen = archive.birthTimeMode === 'shichen'
  
  let normalizedBirthDate: string
  let normalizedTimeIndex: number
  
  // 1. 处理日期：统一转换为公历日期
  if (useLunar && archive.lunarDate) {
    // 农历转公历（需要调用 iztro 或农历转换库）
    normalizedBirthDate = convertLunarToSolar(archive.lunarDate, archive.isLeapMonth ?? false)
  } else {
    // 公历：提取日期部分
    const d = new Date(archive.birthDate)
    normalizedBirthDate = `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}-${String(d.getDate()).padStart(2, '0')}`
  }
  
  // 2. 处理时辰：统一转换为时辰序号（0-12）
  if (useShichen && archive.birthTimeBranch != null) {
    // 时辰模式：直接使用
    normalizedTimeIndex = Math.max(0, Math.min(12, archive.birthTimeBranch))
  } else {
    // 具体时刻模式：应用真太阳时校准后转换为时辰序号
    const birthDate = new Date(archive.birthDate)
    let hour = birthDate.getHours()
    const minute = birthDate.getMinutes()
    
    // 应用真太阳时校准（如果有地点）
    if (archive.birthLocation?.trim()) {
      const longitude = getLongitudeByRegion(archive.birthLocation)
      const offsetMin = getSolarTimeOffsetMinutes(longitude, normalizedBirthDate)
      const totalMinutes = hour * 60 + minute + offsetMin
      const adjusted = ((totalMinutes % 1440) + 1440) % 1440
      hour = Math.floor(adjusted / 60) % 24
    }
    
    // 转换为时辰序号（复用 iztro-service.ts 的 hourToTimeIndex）
    if (hour === 23) {
      normalizedTimeIndex = 12  // 晚子时
    } else {
      normalizedTimeIndex = Math.floor((hour + 1) / 2) % 12
    }
  }
  
  return {
    normalizedBirthDate,
    normalizedTimeIndex
  }
}
```

### 4.2 查询匹配逻辑

```typescript
// 查询相同命盘的档案（基于性别 + 日期 + 时辰）
async function findArchiveByNormalizedBirth(
  gender: 'male' | 'female',
  normalizedBirthDate: string,  // "YYYY-MM-DD"
  normalizedTimeIndex: number   // 0-12
): Promise<ApiArchive | null> {
  const client = getClient()
  
  const { data } = await client
    .from('Archive')
    .select('*')
    .eq('gender', gender)
    .eq('normalized_birth_date', normalizedBirthDate)
    .eq('normalized_time_index', normalizedTimeIndex)
    .order('createdAt', { ascending: false })
    .limit(1)
    .maybeSingle()
  
  return data ? rowToArchive(data) : null
}
```

**说明**：
- 精确匹配：性别、日期、时辰序号完全一致
- 不需要时间容差，因为已经统一转换为时辰序号
- 查询效率高，索引支持快速查找

### 4.3 报告生成时的复用逻辑

**实施位置**：
- 主报告：`src/lib/services/report-service.ts` 的 `generateMainReport()` 函数
- 深度报告：`src/lib/services/deep-report-service.ts` 的 `generateDeepReport()` 函数

**主报告生成流程**（在 `generateMainReport()` 函数中，调用 LLM 之前）：
```typescript
// 在 src/lib/services/report-service.ts 的 generateMainReport() 函数中
export async function generateMainReport(archiveId: string): Promise<ApiMainReport> {
  // 1. 从 DB 获取档案
  const archive = await getArchiveById(archiveId)
  if (!archive) {
    throw new Error(`Archive not found: ${archiveId}`)
  }

  // 2. 【新增】计算标准化命盘信息（日期 + 时辰）
  const normalized = normalizeBirthInfo(archive)
  
  // 3. 【新增】查询是否有相同命盘的已有报告
  const existingArchive = await findArchiveByNormalizedBirth(
    archive.gender,
    normalized.normalizedBirthDate,
    normalized.normalizedTimeIndex
  )
  
  // 4. 【新增】如果找到相同命盘的报告，直接复用（不调用 LLM）
  if (existingArchive && existingArchive.id !== archiveId) {
    const existingReport = await getMainReportByArchiveId(existingArchive.id)
    if (existingReport) {
      // 复制报告内容到新档案
      const newReport: ApiMainReport = {
        ...existingReport,
        id: `report_${Date.now()}_${Math.random().toString(36).slice(2, 9)}`,
        archiveId: archiveId,
        createdAt: new Date().toISOString()
      }
      await createMainReport(newReport)
      return newReport  // 直接返回，不调用 LLM，节省成本
    }
  }
  
  // 5. 如果没有找到，继续原有流程（调用 LLM）
  // 2. 用档案数据计算命盘（iztro）
  const iztroInput = await calculateAstrolabe(archive)
  // ... 后续 LLM 调用逻辑保持不变
}
```

**深度报告生成流程**（在 `generateDeepReport()` 函数中，调用 LLM 之前）：
```typescript
// 在 src/lib/services/deep-report-service.ts 的 generateDeepReport() 函数中
export async function generateDeepReport(
  archiveId: string,
  reportType: DeepReportType
): Promise<void> {
  // 1. 从 DB 获取档案
  const archive = await getArchiveById(archiveId)
  if (!archive) {
    throw new Error(`Archive not found: ${archiveId}`)
  }

  // 2. 【新增】计算标准化命盘信息（日期 + 时辰）
  const normalized = normalizeBirthInfo(archive)
  
  // 3. 【新增】查询是否有相同命盘的已有报告
  const existingArchive = await findArchiveByNormalizedBirth(
    archive.gender,
    normalized.normalizedBirthDate,
    normalized.normalizedTimeIndex
  )
  
  // 4. 【新增】如果找到相同命盘的报告，直接复用（不调用 LLM）
  if (existingArchive && existingArchive.id !== archiveId) {
    const existingReport = await getDeepReportByArchiveAndType(
      existingArchive.id,
      reportType
    )
    if (existingReport) {
      // 复制报告内容到新档案
      await createDeepReport(archiveId, reportType, existingReport.content)
      return  // 直接返回，不调用 LLM，节省成本
    }
  }
  
  // 5. 如果没有找到，继续原有流程（调用 LLM）
  // ... 后续 LLM 调用逻辑保持不变
}
```

## 五、用户体验与能量扣除

### 5.1 用户体验

**重要原则**：用户侧体验完全一致，无论是否相同命盘

- **创建档案**：正常流程，用户填写信息 → 创建档案 → 扣费
- **生成报告**：正常流程，用户发起生成 → 扣费 → 等待/查看报告
- **报告内容**：相同命盘的用户看到完全相同的报告内容（后端复用）

**不向用户提示复用信息**：
- 用户无需知道是否复用了报告
- 用户体验保持一致，避免混淆

### 5.2 能量扣除规则

**统一规则**：无论是否相同命盘，都正常扣费

- **主报告**：
  - 创建档案并生成：扣除能量（无论是否复用）
  - 重新生成：不扣除能量（已有逻辑）

- **深度报告**：
  - 首次生成：扣除能量（无论是否复用）
  - 重新生成：不扣除能量（已有逻辑）

**原因**：用户使用了服务（创建档案、生成报告），应该付费。复用是后端优化，不影响用户侧体验。

## 六、实施步骤

### Phase 1: 数据库和后端
1. ✅ 添加 `normalized_birth_date_time` 和 `normalized_birth_location` 字段到 `Archive` 表
2. ✅ 创建索引
3. ✅ 实现标准化转换函数
4. ✅ 修改 `createArchive` 接口，自动计算并存储标准化字段
5. ✅ 实现 `findArchiveByNormalizedBirth` 查询函数
6. ✅ 实现 `linkReportsToArchive` 关联函数
7. ✅ 新增 API 接口：`GET /api/archives/find-by-birth-info` 和 `POST /api/reports/link-to-archive`

### Phase 2: 后端报告生成逻辑
1. ✅ 修改主报告生成 Worker/API：在生成前查询并复用
2. ✅ 修改深度报告生成 Worker/API：在生成前查询并复用
3. ✅ 确保复用逻辑不影响任务状态和用户侧体验
4. ✅ 测试各种输入方式的复用场景

### Phase 3: 数据迁移（可选）
1. 为现有档案计算并填充 `normalized_birth_date_time` 和 `normalized_birth_location`
2. 验证数据一致性

## 七、风险评估

### 7.1 技术风险
- **农历转换**：农历转公历的准确性需要验证（需要确保与 iztro 库的转换逻辑一致）
- **真太阳时校准**：具体时刻模式需要应用真太阳时校准，确保转换为正确的时辰序号（需要复用 `iztro-service.ts` 的逻辑）
- **时辰边界**：23:00-01:00 对应晚子时和早子时，需要正确处理

### 7.2 业务风险
- **用户隐私**：复用报告可能涉及跨用户数据，需要确保权限控制
- **报告版本**：如果报告生成逻辑更新，旧报告可能不适用新档案

### 7.3 缓解措施
- **复用 iztro-service.ts 的逻辑**：确保标准化转换与命盘计算使用相同的逻辑，保证一致性
- **精确匹配**：基于性别+日期+时辰序号精确匹配，不需要容差
- **记录复用关系**：记录复用关系，便于后续审计和问题排查

## 八、实施要点总结

### 8.1 核心原则
1. **用户侧**：无论是否相同命盘，都正常扣费，体验一致
2. **后端侧**：生成报告时自动检测并复用，节省 LLM 调用成本
3. **结果一致性**：相同命盘的用户看到完全相同的报告内容

### 8.2 实现位置
- **数据库**：添加标准化字段和索引
- **后端 Worker/API**：在报告生成逻辑中添加复用检测
- **前端**：无需变更，保持现有流程

### 8.3 关键函数
- `normalizeBirthDateTime()`: 标准化命盘信息
- `findArchiveByNormalizedBirth()`: 查询相同命盘
- 报告生成函数中：检测 → 复用 or 生成

## 九、后续优化

1. **报告版本管理**：如果报告生成逻辑更新，标记报告版本，新档案优先使用最新版本
2. **部分复用**：如果主报告存在但深度报告不存在，只复用主报告
3. **统计报表**：统计复用率，评估降本效果（记录复用次数，不向用户展示）
4. **缓存优化**：将标准化命盘信息缓存，加速查询
